{"ast":null,"code":"/* vim:ts=4:sts=4:sw=4: */\n/*!\n *\n * Copyright 2009-2013 Kris Kowal under the terms of the MIT\n * license found at http://github.com/kriskowal/q/raw/master/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n/*global -WeakMap */\n\"use strict\";\n\nvar hasStacks = false;\ntry {\n  throw new Error();\n} catch (e) {\n  hasStacks = !!e.stack;\n}\n\n// All code after this point will be filtered from stack traces reported\n// by Q.\nvar qStartingLine = captureLine();\nvar qFileName;\nvar WeakMap = require(\"weak-map\");\nvar iterate = require(\"pop-iterate\");\nvar asap = require(\"asap\");\nfunction isObject(value) {\n  return value === Object(value);\n}\n\n// long stack traces\n\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\nfunction makeStackTraceLong(error, promise) {\n  // If possible, transform the error stack trace by removing Node and Q\n  // cruft, then concatenating with the stack trace of `promise`. See #57.\n  if (hasStacks && promise.stack && typeof error === \"object\" && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {\n    var stacks = [];\n    for (var p = promise; !!p && handlers.get(p); p = handlers.get(p).became) {\n      if (p.stack) {\n        stacks.unshift(p.stack);\n      }\n    }\n    stacks.unshift(error.stack);\n    var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n    error.stack = filterStackString(concatedStacks);\n  }\n}\nfunction filterStackString(stackString) {\n  if (Q.isIntrospective) {\n    return stackString;\n  }\n  var lines = stackString.split(\"\\n\");\n  var desiredLines = [];\n  for (var i = 0; i < lines.length; ++i) {\n    var line = lines[i];\n    if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n      desiredLines.push(line);\n    }\n  }\n  return desiredLines.join(\"\\n\");\n}\nfunction isNodeFrame(stackLine) {\n  return stackLine.indexOf(\"(module.js:\") !== -1 || stackLine.indexOf(\"(node.js:\") !== -1;\n}\nfunction getFileNameAndLineNumber(stackLine) {\n  // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n  // In IE10 function name can have spaces (\"Anonymous function\") O_o\n  var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n  if (attempt1) {\n    return [attempt1[1], Number(attempt1[2])];\n  }\n\n  // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n  var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n  if (attempt2) {\n    return [attempt2[1], Number(attempt2[2])];\n  }\n\n  // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n  var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n  if (attempt3) {\n    return [attempt3[1], Number(attempt3[2])];\n  }\n}\nfunction isInternalFrame(stackLine) {\n  var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n  if (!fileNameAndLineNumber) {\n    return false;\n  }\n  var fileName = fileNameAndLineNumber[0];\n  var lineNumber = fileNameAndLineNumber[1];\n  return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;\n}\n\n// discover own file name and line number range for filtering stack\n// traces\nfunction captureLine() {\n  if (!hasStacks) {\n    return;\n  }\n  try {\n    throw new Error();\n  } catch (e) {\n    var lines = e.stack.split(\"\\n\");\n    var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n    var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n    if (!fileNameAndLineNumber) {\n      return;\n    }\n    qFileName = fileNameAndLineNumber[0];\n    return fileNameAndLineNumber[1];\n  }\n}\nfunction deprecate(callback, name, alternative) {\n  return function Q_deprecate() {\n    if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n      if (alternative) {\n        console.warn(name + \" is deprecated, use \" + alternative + \" instead.\", new Error(\"\").stack);\n      } else {\n        console.warn(name + \" is deprecated.\", new Error(\"\").stack);\n      }\n    }\n    return callback.apply(this, arguments);\n  };\n}\n\n// end of long stack traces\n\nvar handlers = new WeakMap();\nfunction Q_getHandler(promise) {\n  var handler = handlers.get(promise);\n  if (!handler || !handler.became) {\n    return handler;\n  }\n  handler = follow(handler);\n  handlers.set(promise, handler);\n  return handler;\n}\nfunction follow(handler) {\n  if (!handler.became) {\n    return handler;\n  } else {\n    handler.became = follow(handler.became);\n    return handler.became;\n  }\n}\nvar theViciousCycleError = new Error(\"Can't resolve a promise with itself\");\nvar theViciousCycleRejection = Q_reject(theViciousCycleError);\nvar theViciousCycle = Q_getHandler(theViciousCycleRejection);\nvar thenables = new WeakMap();\n\n/**\n * Coerces a value to a promise. If the value is a promise, pass it through\n * unaltered. If the value has a `then` method, it is presumed to be a promise\n * but not one of our own, so it is treated as a “thenable” promise and this\n * returns a promise that stands for it. Otherwise, this returns a promise that\n * has already been fulfilled with the value.\n * @param value promise, object with a then method, or a fulfillment value\n * @returns {Promise} the same promise as given, or a promise for the given\n * value\n */\nmodule.exports = Q;\nfunction Q(value) {\n  // If the object is already a Promise, return it directly.  This enables\n  // the resolve function to both be used to created references from objects,\n  // but to tolerably coerce non-promises to promises.\n  if (Q_isPromise(value)) {\n    return value;\n  } else if (isThenable(value)) {\n    if (!thenables.has(value)) {\n      thenables.set(value, new Promise(new Thenable(value)));\n    }\n    return thenables.get(value);\n  } else {\n    return new Promise(new Fulfilled(value));\n  }\n}\n\n/**\n * Controls whether or not long stack traces will be on\n * @type {boolean}\n */\nQ.longStackSupport = false;\n\n/**\n * Returns a promise that has been rejected with a reason, which should be an\n * instance of `Error`.\n * @param {Error} error reason for the failure.\n * @returns {Promise} rejection\n */\nQ.reject = Q_reject;\nfunction Q_reject(error) {\n  return new Promise(new Rejected(error));\n}\n\n/**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n *\n * @returns {{promise, resolve, reject}} a deferred\n */\nQ.defer = defer;\nfunction defer() {\n  var handler = new Pending();\n  var promise = new Promise(handler);\n  var deferred = new Deferred(promise);\n  if (Q.longStackSupport && hasStacks) {\n    try {\n      throw new Error();\n    } catch (e) {\n      // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n      // accessor around; that causes memory leaks as per GH-111. Just\n      // reify the stack trace as a string ASAP.\n      //\n      // At the same time, cut off the first line; it's always just\n      // \"[object Promise]\\n\", as per the `toString`.\n      promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n    }\n  }\n  return deferred;\n}\n\n// TODO\n/**\n */\nQ.when = function Q_when(value, fulfilled, rejected, ms) {\n  return Q(value).then(fulfilled, rejected, ms);\n};\n\n/**\n * Turns an array of promises into a promise for an array.  If any of the\n * promises gets rejected, the whole array is rejected immediately.\n * @param {Array.<Promise>} an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Promise.<Array>} a promise for an array of the corresponding values\n */\n// By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\nQ.all = Q_all;\nfunction Q_all(questions) {\n  // XXX deprecated behavior\n  if (Q_isPromise(questions)) {\n    if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n      console.warn(\"Q.all no longer directly unwraps a promise. Use Q(array).all()\");\n    }\n    return Q(questions).all();\n  }\n  var countDown = 0;\n  var deferred = defer();\n  var answers = Array(questions.length);\n  var estimates = [];\n  var estimate = -Infinity;\n  var setEstimate;\n  Array.prototype.forEach.call(questions, function Q_all_each(promise, index) {\n    var handler;\n    if (Q_isPromise(promise) && (handler = Q_getHandler(promise)).state === \"fulfilled\") {\n      answers[index] = handler.value;\n    } else {\n      ++countDown;\n      promise = Q(promise);\n      promise.then(function Q_all_eachFulfilled(value) {\n        answers[index] = value;\n        if (--countDown === 0) {\n          deferred.resolve(answers);\n        }\n      }, deferred.reject);\n      promise.observeEstimate(function Q_all_eachEstimate(newEstimate) {\n        var oldEstimate = estimates[index];\n        estimates[index] = newEstimate;\n        if (newEstimate > estimate) {\n          estimate = newEstimate;\n        } else if (oldEstimate === estimate && newEstimate <= estimate) {\n          // There is a 1/length chance that we will need to perform\n          // this O(length) walk, so amortized O(1)\n          computeEstimate();\n        }\n        if (estimates.length === questions.length && estimate !== setEstimate) {\n          deferred.setEstimate(estimate);\n          setEstimate = estimate;\n        }\n      });\n    }\n  });\n  function computeEstimate() {\n    estimate = -Infinity;\n    for (var index = 0; index < estimates.length; index++) {\n      if (estimates[index] > estimate) {\n        estimate = estimates[index];\n      }\n    }\n  }\n  if (countDown === 0) {\n    deferred.resolve(answers);\n  }\n  return deferred.promise;\n}\n\n/**\n * @see Promise#allSettled\n */\nQ.allSettled = Q_allSettled;\nfunction Q_allSettled(questions) {\n  // XXX deprecated behavior\n  if (Q_isPromise(questions)) {\n    if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n      console.warn(\"Q.allSettled no longer directly unwraps a promise. Use Q(array).allSettled()\");\n    }\n    return Q(questions).allSettled();\n  }\n  return Q_all(questions.map(function Q_allSettled_each(promise) {\n    promise = Q(promise);\n    function regardless() {\n      return promise.inspect();\n    }\n    return promise.then(regardless, regardless);\n  }));\n}\n\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\nQ.delay = function Q_delay(object, timeout) {\n  if (timeout === void 0) {\n    timeout = object;\n    object = void 0;\n  }\n  return Q(object).delay(timeout);\n};\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {String} custom error message (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nQ.timeout = function Q_timeout(object, ms, message) {\n  return Q(object).timeout(ms, message);\n};\n\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */\nQ.spread = Q_spread;\nfunction Q_spread(value, fulfilled, rejected) {\n  return Q(value).spread(fulfilled, rejected);\n}\n\n/**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */\nQ.join = function Q_join(x, y) {\n  return Q.spread([x, y], function Q_joined(x, y) {\n    if (x === y) {\n      // TODO: \"===\" should be Object.is or equiv\n      return x;\n    } else {\n      throw new Error(\"Can't join: not the same: \" + x + \" \" + y);\n    }\n  });\n};\n\n/**\n * Returns a promise for the first of an array of promises to become fulfilled.\n * @param answers {Array} promises to race\n * @returns {Promise} the first promise to be fulfilled\n */\nQ.race = Q_race;\nfunction Q_race(answerPs) {\n  return new Promise(function (deferred) {\n    answerPs.forEach(function (answerP) {\n      Q(answerP).then(deferred.resolve, deferred.reject);\n    });\n  });\n}\n\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ.try = function Q_try(callback) {\n  return Q(callback).dispatch(\"call\", [[]]);\n};\n\n/**\n * TODO\n */\nQ.function = Promise_function;\nfunction Promise_function(wrapped) {\n  return function promiseFunctionWrapper() {\n    var args = new Array(arguments.length);\n    for (var index = 0; index < arguments.length; index++) {\n      args[index] = arguments[index];\n    }\n    return Q(wrapped).apply(this, args);\n  };\n}\n\n/**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */\nQ.promised = function Q_promised(callback) {\n  return function promisedMethod() {\n    var args = new Array(arguments.length);\n    for (var index = 0; index < arguments.length; index++) {\n      args[index] = arguments[index];\n    }\n    return Q_spread([this, Q_all(args)], function Q_promised_spread(self, args) {\n      return callback.apply(self, args);\n    });\n  };\n};\n\n/**\n */\nQ.passByCopy =\n// TODO XXX experimental\nQ.push = function (value) {\n  if (Object(value) === value && !Q_isPromise(value)) {\n    passByCopies.set(value, true);\n  }\n  return value;\n};\nQ.isPortable = function (value) {\n  return Object(value) === value && passByCopies.has(value);\n};\nvar passByCopies = new WeakMap();\n\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators. Although generators are only\n * part of the newest ECMAScript 6 drafts, this code does not cause\n * syntax errors in older engines. This code should continue to work\n * and will in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * `--harmony-generators` runtime flag enabled. This function does not\n * support the former, Pythonic generators that were only implemented\n * by SpiderMonkey.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */\nQ.async = Q_async;\nfunction Q_async(makeGenerator) {\n  return function spawn() {\n    // when verb is \"send\", arg is a value\n    // when verb is \"throw\", arg is an exception\n    function continuer(verb, arg) {\n      var iteration;\n      try {\n        iteration = generator[verb](arg);\n      } catch (exception) {\n        return Q_reject(exception);\n      }\n      if (iteration.done) {\n        return Q(iteration.value);\n      } else {\n        return Q(iteration.value).then(callback, errback);\n      }\n    }\n    var generator = makeGenerator.apply(this, arguments);\n    var callback = continuer.bind(continuer, \"next\");\n    var errback = continuer.bind(continuer, \"throw\");\n    return callback();\n  };\n}\n\n/**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */\nQ.spawn = Q_spawn;\nfunction Q_spawn(makeGenerator) {\n  Q_async(makeGenerator)().done();\n}\n\n// Thus begins the section dedicated to the Promise\n\n/**\n * TODO\n */\nQ.Promise = Promise;\nfunction Promise(handler) {\n  if (!(this instanceof Promise)) {\n    return new Promise(handler);\n  }\n  if (typeof handler === \"function\") {\n    var setup = handler;\n    var deferred = defer();\n    handler = Q_getHandler(deferred.promise);\n    try {\n      setup(deferred.resolve, deferred.reject, deferred.setEstimate);\n    } catch (error) {\n      deferred.reject(error);\n    }\n  }\n  handlers.set(this, handler);\n}\n\n/**\n * Turns an array of promises into a promise for an array.  If any of the\n * promises gets rejected, the whole array is rejected immediately.\n * @param {Array.<Promise>} an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Promise.<Array>} a promise for an array of the corresponding values\n */\nPromise.all = Q_all;\n\n/**\n * Returns a promise for the first of an array of promises to become fulfilled.\n * @param answers {Array} promises to race\n * @returns {Promise} the first promise to be fulfilled\n */\nPromise.race = Q_race;\n\n/**\n * Coerces a value to a promise. If the value is a promise, pass it through\n * unaltered. If the value has a `then` method, it is presumed to be a promise\n * but not one of our own, so it is treated as a “thenable” promise and this\n * returns a promise that stands for it. Otherwise, this returns a promise that\n * has already been fulfilled with the value.\n * @param value promise, object with a then method, or a fulfillment value\n * @returns {Promise} the same promise as given, or a promise for the given\n * value\n */\nPromise.resolve = Promise_resolve;\nfunction Promise_resolve(value) {\n  return Q(value);\n}\n\n/**\n * Returns a promise that has been rejected with a reason, which should be an\n * instance of `Error`.\n * @param reason value describing the failure\n * @returns {Promise} rejection\n */\nPromise.reject = Q_reject;\n\n/**\n * @returns {boolean} whether the given value is a promise.\n */\nQ.isPromise = Q_isPromise;\nfunction Q_isPromise(object) {\n  return isObject(object) && !!handlers.get(object);\n}\n\n/**\n * @returns {boolean} whether the given value is an object with a then method.\n * @private\n */\nfunction isThenable(object) {\n  return isObject(object) && typeof object.then === \"function\";\n}\n\n/**\n * Synchronously produces a snapshot of the internal state of the promise.  The\n * object will have a `state` property. If the `state` is `\"pending\"`, there\n * will be no further information. If the `state` is `\"fulfilled\"`, there will\n * be a `value` property. If the state is `\"rejected\"` there will be a `reason`\n * property.  If the promise was constructed from a “thenable” and `then` nor\n * any other method has been dispatched on the promise has been called, the\n * state will be `\"pending\"`. The state object will not be updated if the\n * state changes and changing it will have no effect on the promise. Every\n * call to `inspect` produces a unique object.\n * @returns {{state: string, value?, reason?}}\n */\nPromise.prototype.inspect = function Promise_inspect() {\n  // the second layer captures only the relevant \"state\" properties of the\n  // handler to prevent leaking the capability to access or alter the\n  // handler.\n  return Q_getHandler(this).inspect();\n};\n\n/**\n * @returns {boolean} whether the promise is waiting for a result.\n */\nPromise.prototype.isPending = function Promise_isPending() {\n  return Q_getHandler(this).state === \"pending\";\n};\n\n/**\n * @returns {boolean} whether the promise has ended in a result and has a\n * fulfillment value.\n */\nPromise.prototype.isFulfilled = function Promise_isFulfilled() {\n  return Q_getHandler(this).state === \"fulfilled\";\n};\n\n/**\n * @returns {boolean} whether the promise has ended poorly and has a reason for\n * its rejection.\n */\nPromise.prototype.isRejected = function Promise_isRejected() {\n  return Q_getHandler(this).state === \"rejected\";\n};\n\n/**\n * TODO\n */\nPromise.prototype.toBePassed = function Promise_toBePassed() {\n  return Q_getHandler(this).state === \"passed\";\n};\n\n/**\n * @returns {string} merely `\"[object Promise]\"`\n */\nPromise.prototype.toString = function Promise_toString() {\n  return \"[object Promise]\";\n};\n\n/**\n * Creates a new promise, waits for this promise to be resolved, and informs\n * either the fullfilled or rejected handler of the result. Whatever result\n * comes of the fulfilled or rejected handler, a value returned, a promise\n * returned, or an error thrown, becomes the resolution for the promise\n * returned by `then`.\n *\n * @param fulfilled\n * @param rejected\n * @returns {Promise} for the result of `fulfilled` or `rejected`.\n */\nPromise.prototype.then = function Promise_then(fulfilled, rejected, ms) {\n  var self = this;\n  var deferred = defer();\n  var _fulfilled;\n  if (typeof fulfilled === \"function\") {\n    _fulfilled = function Promise_then_fulfilled(value) {\n      try {\n        deferred.resolve(fulfilled.call(void 0, value));\n      } catch (error) {\n        deferred.reject(error);\n      }\n    };\n  } else {\n    _fulfilled = deferred.resolve;\n  }\n  var _rejected;\n  if (typeof rejected === \"function\") {\n    _rejected = function Promise_then_rejected(error) {\n      try {\n        deferred.resolve(rejected.call(void 0, error));\n      } catch (newError) {\n        deferred.reject(newError);\n      }\n    };\n  } else {\n    _rejected = deferred.reject;\n  }\n  this.done(_fulfilled, _rejected);\n  if (ms !== void 0) {\n    var updateEstimate = function Promise_then_updateEstimate() {\n      deferred.setEstimate(self.getEstimate() + ms);\n    };\n    this.observeEstimate(updateEstimate);\n    updateEstimate();\n  }\n  return deferred.promise;\n};\n\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param fulfilled\n * @param rejected\n */\nPromise.prototype.done = function Promise_done(fulfilled, rejected) {\n  var self = this;\n  var done = false; // ensure the untrusted promise makes at most a\n  // single call to one of the callbacks\n  asap(function Promise_done_task() {\n    var _fulfilled;\n    if (typeof fulfilled === \"function\") {\n      if (Q.onerror) {\n        _fulfilled = function Promise_done_fulfilled(value) {\n          if (done) {\n            return;\n          }\n          done = true;\n          try {\n            fulfilled.call(void 0, value);\n          } catch (error) {\n            // fallback to rethrow is still necessary because\n            // _fulfilled is not called in the same event as the\n            // above guard.\n            (Q.onerror || Promise_rethrow)(error);\n          }\n        };\n      } else {\n        _fulfilled = function Promise_done_fulfilled(value) {\n          if (done) {\n            return;\n          }\n          done = true;\n          fulfilled.call(void 0, value);\n        };\n      }\n    }\n    var _rejected;\n    if (typeof rejected === \"function\" && Q.onerror) {\n      _rejected = function Promise_done_rejected(error) {\n        if (done) {\n          return;\n        }\n        done = true;\n        makeStackTraceLong(error, self);\n        try {\n          rejected.call(void 0, error);\n        } catch (newError) {\n          (Q.onerror || Promise_rethrow)(newError);\n        }\n      };\n    } else if (typeof rejected === \"function\") {\n      _rejected = function Promise_done_rejected(error) {\n        if (done) {\n          return;\n        }\n        done = true;\n        makeStackTraceLong(error, self);\n        rejected.call(void 0, error);\n      };\n    } else {\n      _rejected = Q.onerror || Promise_rethrow;\n    }\n    if (typeof process === \"object\" && process.domain) {\n      _rejected = process.domain.bind(_rejected);\n    }\n    Q_getHandler(self).dispatch(_fulfilled, \"then\", [_rejected]);\n  });\n};\nfunction Promise_rethrow(error) {\n  throw error;\n}\n\n/**\n * TODO\n */\nPromise.prototype.thenResolve = function Promise_thenResolve(value) {\n  // Wrapping ahead of time to forestall multiple wrappers.\n  value = Q(value);\n  // Using all is necessary to aggregate the estimated time to completion.\n  return Q_all([this, value]).then(function Promise_thenResolve_resolved() {\n    return value;\n  }, null, 0);\n  // 0: does not contribute significantly to the estimated time to\n  // completion.\n};\n\n/**\n * TODO\n */\nPromise.prototype.thenReject = function Promise_thenReject(error) {\n  return this.then(function Promise_thenReject_resolved() {\n    throw error;\n  }, null, 0);\n  // 0: does not contribute significantly to the estimated time to\n  // completion.\n};\n\n/**\n * TODO\n */\nPromise.prototype.all = function Promise_all() {\n  return this.then(Q_all);\n};\n\n/**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */\nPromise.prototype.allSettled = function Promise_allSettled() {\n  return this.then(Q_allSettled);\n};\n\n/**\n * TODO\n */\nPromise.prototype.catch = function Promise_catch(rejected) {\n  return this.then(void 0, rejected);\n};\n\n/**\n * TODO\n */\nPromise.prototype.finally = function Promise_finally(callback, ms) {\n  if (!callback) {\n    return this;\n  }\n  callback = Q(callback);\n  return this.then(function (value) {\n    return callback.call().then(function Promise_finally_fulfilled() {\n      return value;\n    });\n  }, function (reason) {\n    // TODO attempt to recycle the rejection with \"this\".\n    return callback.call().then(function Promise_finally_rejected() {\n      throw reason;\n    });\n  }, ms);\n};\n\n/**\n * TODO\n */\nPromise.prototype.observeEstimate = function Promise_observeEstimate(emit) {\n  this.rawDispatch(null, \"estimate\", [emit]);\n  return this;\n};\n\n/**\n * TODO\n */\nPromise.prototype.getEstimate = function Promise_getEstimate() {\n  return Q_getHandler(this).estimate;\n};\n\n/**\n * TODO\n */\nPromise.prototype.dispatch = function Promise_dispatch(op, args) {\n  var deferred = defer();\n  this.rawDispatch(deferred.resolve, op, args);\n  return deferred.promise;\n};\n\n/**\n */\nPromise.prototype.rawDispatch = function Promise_rawDispatch(resolve, op, args) {\n  var self = this;\n  asap(function Promise_dispatch_task() {\n    Q_getHandler(self).dispatch(resolve, op, args);\n  });\n};\n\n/**\n * TODO\n */\nPromise.prototype.get = function Promise_get(name) {\n  return this.dispatch(\"get\", [name]);\n};\n\n/**\n * TODO\n */\nPromise.prototype.invoke = function Promise_invoke(name /*...args*/) {\n  var args = new Array(arguments.length - 1);\n  for (var index = 1; index < arguments.length; index++) {\n    args[index - 1] = arguments[index];\n  }\n  return this.dispatch(\"invoke\", [name, args]);\n};\n\n/**\n * TODO\n */\nPromise.prototype.apply = function Promise_apply(thisp, args) {\n  return this.dispatch(\"call\", [args, thisp]);\n};\n\n/**\n * TODO\n */\nPromise.prototype.call = function Promise_call(thisp /*, ...args*/) {\n  var args = new Array(Math.max(0, arguments.length - 1));\n  for (var index = 1; index < arguments.length; index++) {\n    args[index - 1] = arguments[index];\n  }\n  return this.dispatch(\"call\", [args, thisp]);\n};\n\n/**\n * TODO\n */\nPromise.prototype.bind = function Promise_bind(thisp /*, ...args*/) {\n  var self = this;\n  var args = new Array(Math.max(0, arguments.length - 1));\n  for (var index = 1; index < arguments.length; index++) {\n    args[index - 1] = arguments[index];\n  }\n  return function Promise_bind_bound( /*...args*/\n  ) {\n    var boundArgs = args.slice();\n    for (var index = 0; index < arguments.length; index++) {\n      boundArgs[boundArgs.length] = arguments[index];\n    }\n    return self.dispatch(\"call\", [boundArgs, thisp]);\n  };\n};\n\n/**\n * TODO\n */\nPromise.prototype.keys = function Promise_keys() {\n  return this.dispatch(\"keys\", []);\n};\n\n/**\n * TODO\n */\nPromise.prototype.iterate = function Promise_iterate() {\n  return this.dispatch(\"iterate\", []);\n};\n\n/**\n * TODO\n */\nPromise.prototype.spread = function Promise_spread(fulfilled, rejected, ms) {\n  return this.all().then(function Promise_spread_fulfilled(array) {\n    return fulfilled.apply(void 0, array);\n  }, rejected, ms);\n};\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Number} milliseconds timeout\n * @param {String} custom error message (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nPromise.prototype.timeout = function Promsie_timeout(ms, message) {\n  var deferred = defer();\n  var timeoutId = setTimeout(function Promise_timeout_task() {\n    deferred.reject(new Error(message || \"Timed out after \" + ms + \" ms\"));\n  }, ms);\n  this.then(function Promise_timeout_fulfilled(value) {\n    clearTimeout(timeoutId);\n    deferred.resolve(value);\n  }, function Promise_timeout_rejected(error) {\n    clearTimeout(timeoutId);\n    deferred.reject(error);\n  });\n  return deferred.promise;\n};\n\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\nPromise.prototype.delay = function Promise_delay(ms) {\n  return this.then(function Promise_delay_fulfilled(value) {\n    var deferred = defer();\n    deferred.setEstimate(Date.now() + ms);\n    setTimeout(function Promise_delay_task() {\n      deferred.resolve(value);\n    }, ms);\n    return deferred.promise;\n  }, null, ms);\n};\n\n/**\n * TODO\n */\nPromise.prototype.pull = function Promise_pull() {\n  return this.dispatch(\"pull\", []);\n};\n\n/**\n * TODO\n */\nPromise.prototype.pass = function Promise_pass() {\n  if (!this.toBePassed()) {\n    return new Promise(new Passed(this));\n  } else {\n    return this;\n  }\n};\n\n// Thus begins the portion dedicated to the deferred\n\nvar promises = new WeakMap();\nfunction Deferred(promise) {\n  this.promise = promise;\n  // A deferred has an intrinsic promise, denoted by its hidden handler\n  // property.  The promise property of the deferred may be assigned to a\n  // different promise (as it is in a Queue), but the intrinsic promise does\n  // not change.\n  promises.set(this, promise);\n  var self = this;\n  var resolve = this.resolve;\n  this.resolve = function (value) {\n    resolve.call(self, value);\n  };\n  var reject = this.reject;\n  this.reject = function (error) {\n    reject.call(self, error);\n  };\n}\n\n/**\n * TODO\n */\nDeferred.prototype.resolve = function Deferred_resolve(value) {\n  var handler = Q_getHandler(promises.get(this));\n  if (!handler.messages) {\n    return;\n  }\n  handler.become(Q(value));\n};\n\n/**\n * TODO\n */\nDeferred.prototype.reject = function Deferred_reject(reason) {\n  var handler = Q_getHandler(promises.get(this));\n  if (!handler.messages) {\n    return;\n  }\n  handler.become(Q_reject(reason));\n};\n\n/**\n * TODO\n */\nDeferred.prototype.setEstimate = function Deferred_setEstimate(estimate) {\n  estimate = +estimate;\n  if (estimate !== estimate) {\n    estimate = Infinity;\n  }\n  if (estimate < 1e12 && estimate !== -Infinity) {\n    throw new Error(\"Estimate values should be a number of miliseconds in the future\");\n  }\n  var handler = Q_getHandler(promises.get(this));\n  // TODO There is a bit of capability leakage going on here. The Deferred\n  // should only be able to set the estimate for its original\n  // Pending, not for any handler that promise subsequently became.\n  if (handler.setEstimate) {\n    handler.setEstimate(estimate);\n  }\n};\n\n// Thus ends the public interface\n\n// Thus begins the portion dedicated to handlers\n\nfunction Fulfilled(value) {\n  this.value = value;\n  this.estimate = Date.now();\n}\nFulfilled.prototype.state = \"fulfilled\";\nFulfilled.prototype.inspect = function Fulfilled_inspect() {\n  return {\n    state: \"fulfilled\",\n    value: this.value\n  };\n};\nFulfilled.prototype.dispatch = function Fulfilled_dispatch(resolve, op, operands) {\n  var result;\n  if (op === \"then\" || op === \"get\" || op === \"call\" || op === \"invoke\" || op === \"keys\" || op === \"iterate\" || op === \"pull\") {\n    try {\n      result = this[op].apply(this, operands);\n    } catch (exception) {\n      result = Q_reject(exception);\n    }\n  } else if (op === \"estimate\") {\n    operands[0].call(void 0, this.estimate);\n  } else {\n    var error = new Error(\"Fulfilled promises do not support the \" + op + \" operator\");\n    result = Q_reject(error);\n  }\n  if (resolve) {\n    resolve(result);\n  }\n};\nFulfilled.prototype.then = function Fulfilled_then() {\n  return this.value;\n};\nFulfilled.prototype.get = function Fulfilled_get(name) {\n  return this.value[name];\n};\nFulfilled.prototype.call = function Fulfilled_call(args, thisp) {\n  return this.callInvoke(this.value, args, thisp);\n};\nFulfilled.prototype.invoke = function Fulfilled_invoke(name, args) {\n  return this.callInvoke(this.value[name], args, this.value);\n};\nFulfilled.prototype.callInvoke = function Fulfilled_callInvoke(callback, args, thisp) {\n  var waitToBePassed;\n  for (var index = 0; index < args.length; index++) {\n    if (Q_isPromise(args[index]) && args[index].toBePassed()) {\n      waitToBePassed = waitToBePassed || [];\n      waitToBePassed.push(args[index]);\n    }\n  }\n  if (waitToBePassed) {\n    var self = this;\n    return Q_all(waitToBePassed).then(function () {\n      return self.callInvoke(callback, args.map(function (arg) {\n        if (Q_isPromise(arg) && arg.toBePassed()) {\n          return arg.inspect().value;\n        } else {\n          return arg;\n        }\n      }), thisp);\n    });\n  } else {\n    return callback.apply(thisp, args);\n  }\n};\nFulfilled.prototype.keys = function Fulfilled_keys() {\n  return Object.keys(this.value);\n};\nFulfilled.prototype.iterate = function Fulfilled_iterate() {\n  return iterate(this.value);\n};\nFulfilled.prototype.pull = function Fulfilled_pull() {\n  var result;\n  if (Object(this.value) === this.value) {\n    result = Array.isArray(this.value) ? [] : {};\n    for (var name in this.value) {\n      result[name] = this.value[name];\n    }\n  } else {\n    result = this.value;\n  }\n  return Q.push(result);\n};\nfunction Rejected(reason) {\n  this.reason = reason;\n  this.estimate = Infinity;\n}\nRejected.prototype.state = \"rejected\";\nRejected.prototype.inspect = function Rejected_inspect() {\n  return {\n    state: \"rejected\",\n    reason: this.reason\n  };\n};\nRejected.prototype.dispatch = function Rejected_dispatch(resolve, op, operands) {\n  var result;\n  if (op === \"then\") {\n    result = this.then(resolve, operands[0]);\n  } else {\n    result = this;\n  }\n  if (resolve) {\n    resolve(result);\n  }\n};\nRejected.prototype.then = function Rejected_then(resolve, rejected) {\n  return rejected ? rejected(this.reason) : this;\n};\nfunction Pending() {\n  // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n  // been resolved.  If it is \"undefined\", it has been resolved.  Each\n  // element of the messages array is itself an array of complete arguments to\n  // forward to the resolved promise.  We coerce the resolution value to a\n  // promise using the `resolve` function because it handles both fully\n  // non-thenable values and other thenables gracefully.\n  this.messages = [];\n  this.observers = [];\n  this.estimate = Infinity;\n}\nPending.prototype.state = \"pending\";\nPending.prototype.inspect = function Pending_inspect() {\n  return {\n    state: \"pending\"\n  };\n};\nPending.prototype.dispatch = function Pending_dispatch(resolve, op, operands) {\n  this.messages.push([resolve, op, operands]);\n  if (op === \"estimate\") {\n    this.observers.push(operands[0]);\n    var self = this;\n    asap(function Pending_dispatch_task() {\n      operands[0].call(void 0, self.estimate);\n    });\n  }\n};\nPending.prototype.become = function Pending_become(promise) {\n  this.became = theViciousCycle;\n  var handler = Q_getHandler(promise);\n  this.became = handler;\n  handlers.set(promise, handler);\n  this.promise = void 0;\n  this.messages.forEach(function Pending_become_eachMessage(message) {\n    // makeQ does not have this asap call, so it must be queueing events\n    // downstream. TODO look at makeQ to ascertain\n    asap(function Pending_become_eachMessage_task() {\n      var handler = Q_getHandler(promise);\n      handler.dispatch.apply(handler, message);\n    });\n  });\n  this.messages = void 0;\n  this.observers = void 0;\n};\nPending.prototype.setEstimate = function Pending_setEstimate(estimate) {\n  if (this.observers) {\n    var self = this;\n    self.estimate = estimate;\n    this.observers.forEach(function Pending_eachObserver(observer) {\n      asap(function Pending_setEstimate_eachObserver_task() {\n        observer.call(void 0, estimate);\n      });\n    });\n  }\n};\nfunction Thenable(thenable) {\n  this.thenable = thenable;\n  this.became = null;\n  this.estimate = Infinity;\n}\nThenable.prototype.state = \"thenable\";\nThenable.prototype.inspect = function Thenable_inspect() {\n  return {\n    state: \"pending\"\n  };\n};\nThenable.prototype.cast = function Thenable_cast() {\n  if (!this.became) {\n    var deferred = defer();\n    var thenable = this.thenable;\n    asap(function Thenable_cast_task() {\n      try {\n        thenable.then(deferred.resolve, deferred.reject);\n      } catch (exception) {\n        deferred.reject(exception);\n      }\n    });\n    this.became = Q_getHandler(deferred.promise);\n  }\n  return this.became;\n};\nThenable.prototype.dispatch = function Thenable_dispatch(resolve, op, args) {\n  this.cast().dispatch(resolve, op, args);\n};\nfunction Passed(promise) {\n  this.promise = promise;\n}\nPassed.prototype.state = \"passed\";\nPassed.prototype.inspect = function Passed_inspect() {\n  return this.promise.inspect();\n};\nPassed.prototype.dispatch = function Passed_dispatch(resolve, op, args) {\n  return this.promise.rawDispatch(resolve, op, args);\n};\n\n// Thus begins the Q Node.js bridge\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.ninvoke = function Q_ninvoke(object, name /*...args*/) {\n  var args = new Array(Math.max(0, arguments.length - 1));\n  for (var index = 2; index < arguments.length; index++) {\n    args[index - 2] = arguments[index];\n  }\n  var deferred = Q.defer();\n  args[index - 2] = deferred.makeNodeResolver();\n  Q(object).dispatch(\"invoke\", [name, args]).catch(deferred.reject);\n  return deferred.promise;\n};\nPromise.prototype.ninvoke = function Promise_ninvoke(name /*...args*/) {\n  var args = new Array(arguments.length);\n  for (var index = 1; index < arguments.length; index++) {\n    args[index - 1] = arguments[index];\n  }\n  var deferred = Q.defer();\n  args[index - 1] = deferred.makeNodeResolver();\n  this.dispatch(\"invoke\", [name, args]).catch(deferred.reject);\n  return deferred.promise;\n};\n\n/**\n * Wraps a Node.js continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.denodeify(FS.readFile)(__filename, \"utf-8\")\n * .then(console.log)\n * .done()\n */\nQ.denodeify = function Q_denodeify(callback, pattern) {\n  return function denodeified() {\n    var args = new Array(arguments.length + 1);\n    var index = 0;\n    for (; index < arguments.length; index++) {\n      args[index] = arguments[index];\n    }\n    var deferred = Q.defer();\n    args[index] = deferred.makeNodeResolver(pattern);\n    Q(callback).apply(this, args).catch(deferred.reject);\n    return deferred.promise;\n  };\n};\n\n/**\n * Creates a Node.js-style callback that will resolve or reject the deferred\n * promise.\n * @param unpack `true` means that the Node.js-style-callback accepts a\n * fixed or variable number of arguments and that the deferred should be resolved\n * with an array of these value arguments, or rejected with the error argument.\n * An array of names means that the Node.js-style-callback accepts a fixed\n * number of arguments, and that the resolution should be an object with\n * properties corresponding to the given names and respective value arguments.\n * @returns a nodeback\n */\nDeferred.prototype.makeNodeResolver = function (unpack) {\n  var resolve = this.resolve;\n  if (unpack === true) {\n    return function variadicNodebackToResolver(error) {\n      if (error) {\n        resolve(Q_reject(error));\n      } else {\n        var value = new Array(Math.max(0, arguments.length - 1));\n        for (var index = 1; index < arguments.length; index++) {\n          value[index - 1] = arguments[index];\n        }\n        resolve(value);\n      }\n    };\n  } else if (unpack) {\n    return function namedArgumentNodebackToResolver(error) {\n      if (error) {\n        resolve(Q_reject(error));\n      } else {\n        var value = {};\n        for (var index = 0; index < unpack.length; index++) {\n          value[unpack[index]] = arguments[index + 1];\n        }\n        resolve(value);\n      }\n    };\n  } else {\n    return function nodebackToResolver(error, value) {\n      if (error) {\n        resolve(Q_reject(error));\n      } else {\n        resolve(value);\n      }\n    };\n  }\n};\n\n/**\n * TODO\n */\nPromise.prototype.nodeify = function Promise_nodeify(nodeback) {\n  if (nodeback) {\n    this.done(function (value) {\n      nodeback(null, value);\n    }, nodeback);\n  } else {\n    return this;\n  }\n};\n\n// DEPRECATED\n\nQ.nextTick = deprecate(asap, \"nextTick\", \"asap package\");\nQ.resolve = deprecate(Q, \"resolve\", \"Q\");\nQ.fulfill = deprecate(Q, \"fulfill\", \"Q\");\nQ.isPromiseAlike = deprecate(isThenable, \"isPromiseAlike\", \"(not supported)\");\nQ.fail = deprecate(function (value, rejected) {\n  return Q(value).catch(rejected);\n}, \"Q.fail\", \"Q(value).catch\");\nQ.fin = deprecate(function (value, regardless) {\n  return Q(value).finally(regardless);\n}, \"Q.fin\", \"Q(value).finally\");\nQ.progress = deprecate(function (value) {\n  return value;\n}, \"Q.progress\", \"no longer supported\");\nQ.thenResolve = deprecate(function (promise, value) {\n  return Q(promise).thenResolve(value);\n}, \"thenResolve\", \"Q(value).thenResolve\");\nQ.thenReject = deprecate(function (promise, reason) {\n  return Q(promise).thenResolve(reason);\n}, \"thenResolve\", \"Q(value).thenResolve\");\nQ.isPending = deprecate(function (value) {\n  return Q(value).isPending();\n}, \"isPending\", \"Q(value).isPending\");\nQ.isFulfilled = deprecate(function (value) {\n  return Q(value).isFulfilled();\n}, \"isFulfilled\", \"Q(value).isFulfilled\");\nQ.isRejected = deprecate(function (value) {\n  return Q(value).isRejected();\n}, \"isRejected\", \"Q(value).isRejected\");\nQ.master = deprecate(function (value) {\n  return value;\n}, \"master\", \"no longer necessary\");\nQ.makePromise = function () {\n  throw new Error(\"makePromise is no longer supported\");\n};\nQ.dispatch = deprecate(function (value, op, operands) {\n  return Q(value).dispatch(op, operands);\n}, \"dispatch\", \"Q(value).dispatch\");\nQ.get = deprecate(function (object, name) {\n  return Q(object).get(name);\n}, \"get\", \"Q(value).get\");\nQ.keys = deprecate(function (object) {\n  return Q(object).keys();\n}, \"keys\", \"Q(value).keys\");\nQ.post = deprecate(function (object, name, args) {\n  return Q(object).post(name, args);\n}, \"post\", \"Q(value).invoke (spread arguments)\");\nQ.mapply = deprecate(function (object, name, args) {\n  return Q(object).post(name, args);\n}, \"post\", \"Q(value).invoke (spread arguments)\");\nQ.send = deprecate(function (object, name) {\n  return Q(object).post(name, Array.prototype.slice.call(arguments, 2));\n}, \"send\", \"Q(value).invoke\");\nQ.set = function () {\n  throw new Error(\"Q.set no longer supported\");\n};\nQ.delete = function () {\n  throw new Error(\"Q.delete no longer supported\");\n};\nQ.nearer = deprecate(function (value) {\n  if (Q_isPromise(value) && value.isFulfilled()) {\n    return value.inspect().value;\n  } else {\n    return value;\n  }\n}, \"nearer\", \"inspect().value (+nuances)\");\nQ.fapply = deprecate(function (callback, args) {\n  return Q(callback).dispatch(\"call\", [args]);\n}, \"fapply\", \"Q(callback).apply(thisp, args)\");\nQ.fcall = deprecate(function (callback /*, ...args*/) {\n  return Q(callback).dispatch(\"call\", [Array.prototype.slice.call(arguments, 1)]);\n}, \"fcall\", \"Q(callback).call(thisp, ...args)\");\nQ.fbind = deprecate(function (object /*...args*/) {\n  var promise = Q(object);\n  var args = Array.prototype.slice.call(arguments, 1);\n  return function fbound() {\n    return promise.dispatch(\"call\", [args.concat(Array.prototype.slice.call(arguments)), this]);\n  };\n}, \"fbind\", \"bind with thisp\");\nQ.promise = deprecate(Promise, \"promise\", \"Promise\");\nPromise.prototype.fapply = deprecate(function (args) {\n  return this.dispatch(\"call\", [args]);\n}, \"fapply\", \"apply with thisp\");\nPromise.prototype.fcall = deprecate(function /*...args*/\n() {\n  return this.dispatch(\"call\", [Array.prototype.slice.call(arguments)]);\n}, \"fcall\", \"try or call with thisp\");\nPromise.prototype.fail = deprecate(function (rejected) {\n  return this.catch(rejected);\n}, \"fail\", \"catch\");\nPromise.prototype.fin = deprecate(function (regardless) {\n  return this.finally(regardless);\n}, \"fin\", \"finally\");\nPromise.prototype.set = function () {\n  throw new Error(\"Promise set no longer supported\");\n};\nPromise.prototype.delete = function () {\n  throw new Error(\"Promise delete no longer supported\");\n};\nDeferred.prototype.notify = deprecate(function () {}, \"notify\", \"no longer supported\");\nPromise.prototype.progress = deprecate(function () {\n  return this;\n}, \"progress\", \"no longer supported\");\n\n// alternative proposed by Redsandro, dropped in favor of post to streamline\n// the interface\nPromise.prototype.mapply = deprecate(function (name, args) {\n  return this.dispatch(\"invoke\", [name, args]);\n}, \"mapply\", \"invoke\");\nPromise.prototype.fbind = deprecate(function () {\n  return Q.fbind.apply(Q, [void 0].concat(Array.prototype.slice.call(arguments)));\n}, \"fbind\", \"bind(thisp, ...args)\");\n\n// alternative proposed by Mark Miller, dropped in favor of invoke\nPromise.prototype.send = deprecate(function () {\n  return this.dispatch(\"invoke\", [name, Array.prototype.slice.call(arguments, 1)]);\n}, \"send\", \"invoke\");\n\n// alternative proposed by Redsandro, dropped in favor of invoke\nPromise.prototype.mcall = deprecate(function () {\n  return this.dispatch(\"invoke\", [name, Array.prototype.slice.call(arguments, 1)]);\n}, \"mcall\", \"invoke\");\nPromise.prototype.passByCopy = deprecate(function (value) {\n  return value;\n}, \"passByCopy\", \"Q.passByCopy\");\n\n// Deprecated Node.js bridge promise methods\n\nQ.nfapply = deprecate(function (callback, args) {\n  var deferred = Q.defer();\n  var nodeArgs = Array.prototype.slice.call(args);\n  nodeArgs.push(deferred.makeNodeResolver());\n  Q(callback).apply(this, nodeArgs).catch(deferred.reject);\n  return deferred.promise;\n}, \"nfapply\");\nPromise.prototype.nfapply = deprecate(function (args) {\n  return Q.nfapply(this, args);\n}, \"nfapply\");\nQ.nfcall = deprecate(function (callback /*...args*/) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return Q.nfapply(callback, args);\n}, \"nfcall\");\nPromise.prototype.nfcall = deprecate(function () {\n  var args = new Array(arguments.length);\n  for (var index = 0; index < arguments.length; index++) {\n    args[index] = arguments[index];\n  }\n  return Q.nfapply(this, args);\n}, \"nfcall\");\nQ.nfbind = deprecate(function (callback /*...args*/) {\n  var baseArgs = Array.prototype.slice.call(arguments, 1);\n  return function () {\n    var nodeArgs = baseArgs.concat(Array.prototype.slice.call(arguments));\n    var deferred = Q.defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(callback).apply(this, nodeArgs).catch(deferred.reject);\n    return deferred.promise;\n  };\n}, \"nfbind\", \"denodeify (with caveats)\");\nPromise.prototype.nfbind = deprecate(function () {\n  var args = new Array(arguments.length);\n  for (var index = 0; index < arguments.length; index++) {\n    args[index] = arguments[index];\n  }\n  return Q.nfbind(this, args);\n}, \"nfbind\", \"denodeify (with caveats)\");\nQ.nbind = deprecate(function (callback, thisp /*...args*/) {\n  var baseArgs = Array.prototype.slice.call(arguments, 2);\n  return function () {\n    var nodeArgs = baseArgs.concat(Array.prototype.slice.call(arguments));\n    var deferred = Q.defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    function bound() {\n      return callback.apply(thisp, arguments);\n    }\n    Q(bound).apply(this, nodeArgs).catch(deferred.reject);\n    return deferred.promise;\n  };\n}, \"nbind\", \"denodeify (with caveats)\");\nQ.npost = deprecate(function (object, name, nodeArgs) {\n  var deferred = Q.defer();\n  nodeArgs.push(deferred.makeNodeResolver());\n  Q(object).dispatch(\"invoke\", [name, nodeArgs]).catch(deferred.reject);\n  return deferred.promise;\n}, \"npost\", \"ninvoke (with spread arguments)\");\nPromise.prototype.npost = deprecate(function (name, args) {\n  return Q.npost(this, name, args);\n}, \"npost\", \"Q.ninvoke (with caveats)\");\nQ.nmapply = deprecate(Q.nmapply, \"nmapply\", \"q/node nmapply\");\nPromise.prototype.nmapply = deprecate(Promise.prototype.npost, \"nmapply\", \"Q.nmapply\");\nQ.nsend = deprecate(Q.ninvoke, \"nsend\", \"q/node ninvoke\");\nQ.nmcall = deprecate(Q.ninvoke, \"nmcall\", \"q/node ninvoke\");\nPromise.prototype.nsend = deprecate(Promise.prototype.ninvoke, \"nsend\", \"q/node ninvoke\");\nPromise.prototype.nmcall = deprecate(Promise.prototype.ninvoke, \"nmcall\", \"q/node ninvoke\");\n\n// All code before this point will be filtered from stack traces.\nvar qEndingLine = captureLine();","map":{"version":3,"names":["hasStacks","Error","e","stack","qStartingLine","captureLine","qFileName","WeakMap","require","iterate","asap","isObject","value","Object","STACK_JUMP_SEPARATOR","makeStackTraceLong","error","promise","indexOf","stacks","p","handlers","get","became","unshift","concatedStacks","join","filterStackString","stackString","Q","isIntrospective","lines","split","desiredLines","i","length","line","isInternalFrame","isNodeFrame","push","stackLine","getFileNameAndLineNumber","attempt1","exec","Number","attempt2","attempt3","fileNameAndLineNumber","fileName","lineNumber","qEndingLine","firstLine","deprecate","callback","name","alternative","Q_deprecate","console","warn","apply","arguments","Q_getHandler","handler","follow","set","theViciousCycleError","theViciousCycleRejection","Q_reject","theViciousCycle","thenables","module","exports","Q_isPromise","isThenable","has","Promise","Thenable","Fulfilled","longStackSupport","reject","Rejected","defer","Pending","deferred","Deferred","substring","when","Q_when","fulfilled","rejected","ms","then","all","Q_all","questions","countDown","answers","Array","estimates","estimate","Infinity","setEstimate","prototype","forEach","call","Q_all_each","index","state","Q_all_eachFulfilled","resolve","observeEstimate","Q_all_eachEstimate","newEstimate","oldEstimate","computeEstimate","allSettled","Q_allSettled","map","Q_allSettled_each","regardless","inspect","delay","Q_delay","object","timeout","Q_timeout","message","spread","Q_spread","Q_join","x","y","Q_joined","race","Q_race","answerPs","answerP","try","Q_try","dispatch","function","Promise_function","wrapped","promiseFunctionWrapper","args","promised","Q_promised","promisedMethod","Q_promised_spread","self","passByCopy","passByCopies","isPortable","async","Q_async","makeGenerator","spawn","continuer","verb","arg","iteration","generator","exception","done","errback","bind","Q_spawn","setup","Promise_resolve","isPromise","Promise_inspect","isPending","Promise_isPending","isFulfilled","Promise_isFulfilled","isRejected","Promise_isRejected","toBePassed","Promise_toBePassed","toString","Promise_toString","Promise_then","_fulfilled","Promise_then_fulfilled","_rejected","Promise_then_rejected","newError","updateEstimate","Promise_then_updateEstimate","getEstimate","Promise_done","Promise_done_task","onerror","Promise_done_fulfilled","Promise_rethrow","Promise_done_rejected","process","domain","thenResolve","Promise_thenResolve","Promise_thenResolve_resolved","thenReject","Promise_thenReject","Promise_thenReject_resolved","Promise_all","Promise_allSettled","catch","Promise_catch","finally","Promise_finally","Promise_finally_fulfilled","reason","Promise_finally_rejected","Promise_observeEstimate","emit","rawDispatch","Promise_getEstimate","Promise_dispatch","op","Promise_rawDispatch","Promise_dispatch_task","Promise_get","invoke","Promise_invoke","Promise_apply","thisp","Promise_call","Math","max","Promise_bind","Promise_bind_bound","boundArgs","slice","keys","Promise_keys","Promise_iterate","Promise_spread","Promise_spread_fulfilled","array","Promsie_timeout","timeoutId","setTimeout","Promise_timeout_task","Promise_timeout_fulfilled","clearTimeout","Promise_timeout_rejected","Promise_delay","Promise_delay_fulfilled","Date","now","Promise_delay_task","pull","Promise_pull","pass","Promise_pass","Passed","promises","Deferred_resolve","messages","become","Deferred_reject","Deferred_setEstimate","Fulfilled_inspect","Fulfilled_dispatch","operands","result","Fulfilled_then","Fulfilled_get","Fulfilled_call","callInvoke","Fulfilled_invoke","Fulfilled_callInvoke","waitToBePassed","Fulfilled_keys","Fulfilled_iterate","Fulfilled_pull","isArray","Rejected_inspect","Rejected_dispatch","Rejected_then","observers","Pending_inspect","Pending_dispatch","Pending_dispatch_task","Pending_become","Pending_become_eachMessage","Pending_become_eachMessage_task","Pending_setEstimate","Pending_eachObserver","observer","Pending_setEstimate_eachObserver_task","thenable","Thenable_inspect","cast","Thenable_cast","Thenable_cast_task","Thenable_dispatch","Passed_inspect","Passed_dispatch","ninvoke","Q_ninvoke","makeNodeResolver","Promise_ninvoke","denodeify","Q_denodeify","pattern","denodeified","unpack","variadicNodebackToResolver","namedArgumentNodebackToResolver","nodebackToResolver","nodeify","Promise_nodeify","nodeback","nextTick","fulfill","isPromiseAlike","fail","fin","progress","master","makePromise","post","mapply","send","delete","nearer","fapply","fcall","fbind","fbound","concat","notify","mcall","nfapply","nodeArgs","nfcall","nfbind","baseArgs","nbind","bound","npost","nmapply","nsend","nmcall"],"sources":["C:/Users/spoon/Documents/GitHub/SDI/transportes-app/frontend/node_modules/twilio/node_modules/q/q.js"],"sourcesContent":["/* vim:ts=4:sts=4:sw=4: */\n/*!\n *\n * Copyright 2009-2013 Kris Kowal under the terms of the MIT\n * license found at http://github.com/kriskowal/q/raw/master/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n/*global -WeakMap */\n\"use strict\";\n\nvar hasStacks = false;\ntry {\n    throw new Error();\n} catch (e) {\n    hasStacks = !!e.stack;\n}\n\n// All code after this point will be filtered from stack traces reported\n// by Q.\nvar qStartingLine = captureLine();\nvar qFileName;\n\nvar WeakMap = require(\"weak-map\");\nvar iterate = require(\"pop-iterate\");\nvar asap = require(\"asap\");\n\nfunction isObject(value) {\n    return value === Object(value);\n}\n\n// long stack traces\n\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\nfunction makeStackTraceLong(error, promise) {\n    // If possible, transform the error stack trace by removing Node and Q\n    // cruft, then concatenating with the stack trace of `promise`. See #57.\n    if (hasStacks &&\n        promise.stack &&\n        typeof error === \"object\" &&\n        error !== null &&\n        error.stack &&\n        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1\n    ) {\n        var stacks = [];\n        for (var p = promise; !!p && handlers.get(p); p = handlers.get(p).became) {\n            if (p.stack) {\n                stacks.unshift(p.stack);\n            }\n        }\n        stacks.unshift(error.stack);\n\n        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n        error.stack = filterStackString(concatedStacks);\n    }\n}\n\nfunction filterStackString(stackString) {\n    if (Q.isIntrospective) {\n        return stackString;\n    }\n    var lines = stackString.split(\"\\n\");\n    var desiredLines = [];\n    for (var i = 0; i < lines.length; ++i) {\n        var line = lines[i];\n\n        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n            desiredLines.push(line);\n        }\n    }\n    return desiredLines.join(\"\\n\");\n}\n\nfunction isNodeFrame(stackLine) {\n    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n           stackLine.indexOf(\"(node.js:\") !== -1;\n}\n\nfunction getFileNameAndLineNumber(stackLine) {\n    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n    if (attempt1) {\n        return [attempt1[1], Number(attempt1[2])];\n    }\n\n    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n    if (attempt2) {\n        return [attempt2[1], Number(attempt2[2])];\n    }\n\n    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n    if (attempt3) {\n        return [attempt3[1], Number(attempt3[2])];\n    }\n}\n\nfunction isInternalFrame(stackLine) {\n    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\n    if (!fileNameAndLineNumber) {\n        return false;\n    }\n\n    var fileName = fileNameAndLineNumber[0];\n    var lineNumber = fileNameAndLineNumber[1];\n\n    return fileName === qFileName &&\n        lineNumber >= qStartingLine &&\n        lineNumber <= qEndingLine;\n}\n\n// discover own file name and line number range for filtering stack\n// traces\nfunction captureLine() {\n    if (!hasStacks) {\n        return;\n    }\n\n    try {\n        throw new Error();\n    } catch (e) {\n        var lines = e.stack.split(\"\\n\");\n        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n        if (!fileNameAndLineNumber) {\n            return;\n        }\n\n        qFileName = fileNameAndLineNumber[0];\n        return fileNameAndLineNumber[1];\n    }\n}\n\nfunction deprecate(callback, name, alternative) {\n    return function Q_deprecate() {\n        if (\n            typeof console !== \"undefined\" &&\n            typeof console.warn === \"function\"\n        ) {\n            if (alternative) {\n                console.warn(\n                    name + \" is deprecated, use \" + alternative + \" instead.\",\n                    new Error(\"\").stack\n                );\n            } else {\n                console.warn(\n                    name + \" is deprecated.\",\n                    new Error(\"\").stack\n                );\n            }\n        }\n        return callback.apply(this, arguments);\n    };\n}\n\n// end of long stack traces\n\nvar handlers = new WeakMap();\n\nfunction Q_getHandler(promise) {\n    var handler = handlers.get(promise);\n    if (!handler || !handler.became) {\n        return handler;\n    }\n    handler = follow(handler);\n    handlers.set(promise, handler);\n    return handler;\n}\n\nfunction follow(handler) {\n    if (!handler.became) {\n        return handler;\n    } else {\n        handler.became = follow(handler.became);\n        return handler.became;\n    }\n}\n\nvar theViciousCycleError = new Error(\"Can't resolve a promise with itself\");\nvar theViciousCycleRejection = Q_reject(theViciousCycleError);\nvar theViciousCycle = Q_getHandler(theViciousCycleRejection);\n\nvar thenables = new WeakMap();\n\n/**\n * Coerces a value to a promise. If the value is a promise, pass it through\n * unaltered. If the value has a `then` method, it is presumed to be a promise\n * but not one of our own, so it is treated as a “thenable” promise and this\n * returns a promise that stands for it. Otherwise, this returns a promise that\n * has already been fulfilled with the value.\n * @param value promise, object with a then method, or a fulfillment value\n * @returns {Promise} the same promise as given, or a promise for the given\n * value\n */\nmodule.exports = Q;\nfunction Q(value) {\n    // If the object is already a Promise, return it directly.  This enables\n    // the resolve function to both be used to created references from objects,\n    // but to tolerably coerce non-promises to promises.\n    if (Q_isPromise(value)) {\n        return value;\n    } else if (isThenable(value)) {\n        if (!thenables.has(value)) {\n            thenables.set(value, new Promise(new Thenable(value)));\n        }\n        return thenables.get(value);\n    } else {\n        return new Promise(new Fulfilled(value));\n    }\n}\n\n/**\n * Controls whether or not long stack traces will be on\n * @type {boolean}\n */\nQ.longStackSupport = false;\n\n/**\n * Returns a promise that has been rejected with a reason, which should be an\n * instance of `Error`.\n * @param {Error} error reason for the failure.\n * @returns {Promise} rejection\n */\nQ.reject = Q_reject;\nfunction Q_reject(error) {\n    return new Promise(new Rejected(error));\n}\n\n/**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n *\n * @returns {{promise, resolve, reject}} a deferred\n */\nQ.defer = defer;\nfunction defer() {\n\n    var handler = new Pending();\n    var promise = new Promise(handler);\n    var deferred = new Deferred(promise);\n\n    if (Q.longStackSupport && hasStacks) {\n        try {\n            throw new Error();\n        } catch (e) {\n            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n            // accessor around; that causes memory leaks as per GH-111. Just\n            // reify the stack trace as a string ASAP.\n            //\n            // At the same time, cut off the first line; it's always just\n            // \"[object Promise]\\n\", as per the `toString`.\n            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n        }\n    }\n\n    return deferred;\n}\n\n// TODO\n/**\n */\nQ.when = function Q_when(value, fulfilled, rejected, ms) {\n    return Q(value).then(fulfilled, rejected, ms);\n};\n\n/**\n * Turns an array of promises into a promise for an array.  If any of the\n * promises gets rejected, the whole array is rejected immediately.\n * @param {Array.<Promise>} an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Promise.<Array>} a promise for an array of the corresponding values\n */\n// By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\nQ.all = Q_all;\nfunction Q_all(questions) {\n    // XXX deprecated behavior\n    if (Q_isPromise(questions)) {\n        if (\n            typeof console !== \"undefined\" &&\n            typeof console.warn === \"function\"\n        ) {\n            console.warn(\"Q.all no longer directly unwraps a promise. Use Q(array).all()\");\n        }\n        return Q(questions).all();\n    }\n    var countDown = 0;\n    var deferred = defer();\n    var answers = Array(questions.length);\n    var estimates = [];\n    var estimate = -Infinity;\n    var setEstimate;\n    Array.prototype.forEach.call(questions, function Q_all_each(promise, index) {\n        var handler;\n        if (\n            Q_isPromise(promise) &&\n            (handler = Q_getHandler(promise)).state === \"fulfilled\"\n        ) {\n            answers[index] = handler.value;\n        } else {\n            ++countDown;\n            promise = Q(promise);\n            promise.then(\n                function Q_all_eachFulfilled(value) {\n                    answers[index] = value;\n                    if (--countDown === 0) {\n                        deferred.resolve(answers);\n                    }\n                },\n                deferred.reject\n            );\n\n            promise.observeEstimate(function Q_all_eachEstimate(newEstimate) {\n                var oldEstimate = estimates[index];\n                estimates[index] = newEstimate;\n                if (newEstimate > estimate) {\n                    estimate = newEstimate;\n                } else if (oldEstimate === estimate && newEstimate <= estimate) {\n                    // There is a 1/length chance that we will need to perform\n                    // this O(length) walk, so amortized O(1)\n                    computeEstimate();\n                }\n                if (estimates.length === questions.length && estimate !== setEstimate) {\n                    deferred.setEstimate(estimate);\n                    setEstimate = estimate;\n                }\n            });\n\n        }\n    });\n\n    function computeEstimate() {\n        estimate = -Infinity;\n        for (var index = 0; index < estimates.length; index++) {\n            if (estimates[index] > estimate) {\n                estimate = estimates[index];\n            }\n        }\n    }\n\n    if (countDown === 0) {\n        deferred.resolve(answers);\n    }\n\n    return deferred.promise;\n}\n\n/**\n * @see Promise#allSettled\n */\nQ.allSettled = Q_allSettled;\nfunction Q_allSettled(questions) {\n    // XXX deprecated behavior\n    if (Q_isPromise(questions)) {\n        if (\n            typeof console !== \"undefined\" &&\n            typeof console.warn === \"function\"\n        ) {\n            console.warn(\"Q.allSettled no longer directly unwraps a promise. Use Q(array).allSettled()\");\n        }\n        return Q(questions).allSettled();\n    }\n    return Q_all(questions.map(function Q_allSettled_each(promise) {\n        promise = Q(promise);\n        function regardless() {\n            return promise.inspect();\n        }\n        return promise.then(regardless, regardless);\n    }));\n}\n\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\nQ.delay = function Q_delay(object, timeout) {\n    if (timeout === void 0) {\n        timeout = object;\n        object = void 0;\n    }\n    return Q(object).delay(timeout);\n};\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {String} custom error message (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nQ.timeout = function Q_timeout(object, ms, message) {\n    return Q(object).timeout(ms, message);\n};\n\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */\nQ.spread = Q_spread;\nfunction Q_spread(value, fulfilled, rejected) {\n    return Q(value).spread(fulfilled, rejected);\n}\n\n/**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */\nQ.join = function Q_join(x, y) {\n    return Q.spread([x, y], function Q_joined(x, y) {\n        if (x === y) {\n            // TODO: \"===\" should be Object.is or equiv\n            return x;\n        } else {\n            throw new Error(\"Can't join: not the same: \" + x + \" \" + y);\n        }\n    });\n};\n\n/**\n * Returns a promise for the first of an array of promises to become fulfilled.\n * @param answers {Array} promises to race\n * @returns {Promise} the first promise to be fulfilled\n */\nQ.race = Q_race;\nfunction Q_race(answerPs) {\n    return new Promise(function(deferred) {\n        answerPs.forEach(function(answerP) {\n            Q(answerP).then(deferred.resolve, deferred.reject);\n        });\n    });\n}\n\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ.try = function Q_try(callback) {\n    return Q(callback).dispatch(\"call\", [[]]);\n};\n\n/**\n * TODO\n */\nQ.function = Promise_function;\nfunction Promise_function(wrapped) {\n    return function promiseFunctionWrapper() {\n        var args = new Array(arguments.length);\n        for (var index = 0; index < arguments.length; index++) {\n            args[index] = arguments[index];\n        }\n        return Q(wrapped).apply(this, args);\n    };\n}\n\n/**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */\nQ.promised = function Q_promised(callback) {\n    return function promisedMethod() {\n        var args = new Array(arguments.length);\n        for (var index = 0; index < arguments.length; index++) {\n            args[index] = arguments[index];\n        }\n        return Q_spread(\n            [this, Q_all(args)],\n            function Q_promised_spread(self, args) {\n                return callback.apply(self, args);\n            }\n        );\n    };\n};\n\n/**\n */\nQ.passByCopy = // TODO XXX experimental\nQ.push = function (value) {\n    if (Object(value) === value && !Q_isPromise(value)) {\n        passByCopies.set(value, true);\n    }\n    return value;\n};\n\nQ.isPortable = function (value) {\n    return Object(value) === value && passByCopies.has(value);\n};\n\nvar passByCopies = new WeakMap();\n\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators. Although generators are only\n * part of the newest ECMAScript 6 drafts, this code does not cause\n * syntax errors in older engines. This code should continue to work\n * and will in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * `--harmony-generators` runtime flag enabled. This function does not\n * support the former, Pythonic generators that were only implemented\n * by SpiderMonkey.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */\nQ.async = Q_async;\nfunction Q_async(makeGenerator) {\n    return function spawn() {\n        // when verb is \"send\", arg is a value\n        // when verb is \"throw\", arg is an exception\n        function continuer(verb, arg) {\n            var iteration;\n            try {\n                iteration = generator[verb](arg);\n            } catch (exception) {\n                return Q_reject(exception);\n            }\n            if (iteration.done) {\n                return Q(iteration.value);\n            } else {\n                return Q(iteration.value).then(callback, errback);\n            }\n        }\n        var generator = makeGenerator.apply(this, arguments);\n        var callback = continuer.bind(continuer, \"next\");\n        var errback = continuer.bind(continuer, \"throw\");\n        return callback();\n    };\n}\n\n/**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */\nQ.spawn = Q_spawn;\nfunction Q_spawn(makeGenerator) {\n    Q_async(makeGenerator)().done();\n}\n\n\n// Thus begins the section dedicated to the Promise\n\n/**\n * TODO\n */\nQ.Promise = Promise;\nfunction Promise(handler) {\n    if (!(this instanceof Promise)) {\n        return new Promise(handler);\n    }\n    if (typeof handler === \"function\") {\n        var setup = handler;\n        var deferred = defer();\n        handler = Q_getHandler(deferred.promise);\n        try {\n            setup(deferred.resolve, deferred.reject, deferred.setEstimate);\n        } catch (error) {\n            deferred.reject(error);\n        }\n    }\n    handlers.set(this, handler);\n}\n\n/**\n * Turns an array of promises into a promise for an array.  If any of the\n * promises gets rejected, the whole array is rejected immediately.\n * @param {Array.<Promise>} an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Promise.<Array>} a promise for an array of the corresponding values\n */\nPromise.all = Q_all;\n\n/**\n * Returns a promise for the first of an array of promises to become fulfilled.\n * @param answers {Array} promises to race\n * @returns {Promise} the first promise to be fulfilled\n */\nPromise.race = Q_race;\n\n/**\n * Coerces a value to a promise. If the value is a promise, pass it through\n * unaltered. If the value has a `then` method, it is presumed to be a promise\n * but not one of our own, so it is treated as a “thenable” promise and this\n * returns a promise that stands for it. Otherwise, this returns a promise that\n * has already been fulfilled with the value.\n * @param value promise, object with a then method, or a fulfillment value\n * @returns {Promise} the same promise as given, or a promise for the given\n * value\n */\nPromise.resolve = Promise_resolve;\nfunction Promise_resolve(value) {\n    return Q(value);\n}\n\n/**\n * Returns a promise that has been rejected with a reason, which should be an\n * instance of `Error`.\n * @param reason value describing the failure\n * @returns {Promise} rejection\n */\nPromise.reject = Q_reject;\n\n/**\n * @returns {boolean} whether the given value is a promise.\n */\nQ.isPromise = Q_isPromise;\nfunction Q_isPromise(object) {\n    return isObject(object) && !!handlers.get(object);\n}\n\n/**\n * @returns {boolean} whether the given value is an object with a then method.\n * @private\n */\nfunction isThenable(object) {\n    return isObject(object) && typeof object.then === \"function\";\n}\n\n/**\n * Synchronously produces a snapshot of the internal state of the promise.  The\n * object will have a `state` property. If the `state` is `\"pending\"`, there\n * will be no further information. If the `state` is `\"fulfilled\"`, there will\n * be a `value` property. If the state is `\"rejected\"` there will be a `reason`\n * property.  If the promise was constructed from a “thenable” and `then` nor\n * any other method has been dispatched on the promise has been called, the\n * state will be `\"pending\"`. The state object will not be updated if the\n * state changes and changing it will have no effect on the promise. Every\n * call to `inspect` produces a unique object.\n * @returns {{state: string, value?, reason?}}\n */\nPromise.prototype.inspect = function Promise_inspect() {\n    // the second layer captures only the relevant \"state\" properties of the\n    // handler to prevent leaking the capability to access or alter the\n    // handler.\n    return Q_getHandler(this).inspect();\n};\n\n/**\n * @returns {boolean} whether the promise is waiting for a result.\n */\nPromise.prototype.isPending = function Promise_isPending() {\n    return Q_getHandler(this).state === \"pending\";\n};\n\n/**\n * @returns {boolean} whether the promise has ended in a result and has a\n * fulfillment value.\n */\nPromise.prototype.isFulfilled = function Promise_isFulfilled() {\n    return Q_getHandler(this).state === \"fulfilled\";\n};\n\n/**\n * @returns {boolean} whether the promise has ended poorly and has a reason for\n * its rejection.\n */\nPromise.prototype.isRejected = function Promise_isRejected() {\n    return Q_getHandler(this).state === \"rejected\";\n};\n\n/**\n * TODO\n */\nPromise.prototype.toBePassed = function Promise_toBePassed() {\n    return Q_getHandler(this).state === \"passed\";\n};\n\n/**\n * @returns {string} merely `\"[object Promise]\"`\n */\nPromise.prototype.toString = function Promise_toString() {\n    return \"[object Promise]\";\n};\n\n/**\n * Creates a new promise, waits for this promise to be resolved, and informs\n * either the fullfilled or rejected handler of the result. Whatever result\n * comes of the fulfilled or rejected handler, a value returned, a promise\n * returned, or an error thrown, becomes the resolution for the promise\n * returned by `then`.\n *\n * @param fulfilled\n * @param rejected\n * @returns {Promise} for the result of `fulfilled` or `rejected`.\n */\nPromise.prototype.then = function Promise_then(fulfilled, rejected, ms) {\n    var self = this;\n    var deferred = defer();\n\n    var _fulfilled;\n    if (typeof fulfilled === \"function\") {\n        _fulfilled = function Promise_then_fulfilled(value) {\n            try {\n                deferred.resolve(fulfilled.call(void 0, value));\n            } catch (error) {\n                deferred.reject(error);\n            }\n        };\n    } else {\n        _fulfilled = deferred.resolve;\n    }\n\n    var _rejected;\n    if (typeof rejected === \"function\") {\n        _rejected = function Promise_then_rejected(error) {\n            try {\n                deferred.resolve(rejected.call(void 0, error));\n            } catch (newError) {\n                deferred.reject(newError);\n            }\n        };\n    } else {\n        _rejected = deferred.reject;\n    }\n\n    this.done(_fulfilled, _rejected);\n\n    if (ms !== void 0) {\n        var updateEstimate = function Promise_then_updateEstimate() {\n            deferred.setEstimate(self.getEstimate() + ms);\n        };\n        this.observeEstimate(updateEstimate);\n        updateEstimate();\n    }\n\n    return deferred.promise;\n};\n\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param fulfilled\n * @param rejected\n */\nPromise.prototype.done = function Promise_done(fulfilled, rejected) {\n    var self = this;\n    var done = false;   // ensure the untrusted promise makes at most a\n                        // single call to one of the callbacks\n    asap(function Promise_done_task() {\n        var _fulfilled;\n        if (typeof fulfilled === \"function\") {\n            if (Q.onerror) {\n                _fulfilled = function Promise_done_fulfilled(value) {\n                    if (done) {\n                        return;\n                    }\n                    done = true;\n                    try {\n                        fulfilled.call(void 0, value);\n                    } catch (error) {\n                        // fallback to rethrow is still necessary because\n                        // _fulfilled is not called in the same event as the\n                        // above guard.\n                        (Q.onerror || Promise_rethrow)(error);\n                    }\n                };\n            } else {\n                _fulfilled = function Promise_done_fulfilled(value) {\n                    if (done) {\n                        return;\n                    }\n                    done = true;\n                    fulfilled.call(void 0, value);\n                };\n            }\n        }\n\n        var _rejected;\n        if (typeof rejected === \"function\" && Q.onerror) {\n            _rejected = function Promise_done_rejected(error) {\n                if (done) {\n                    return;\n                }\n                done = true;\n                makeStackTraceLong(error, self);\n                try {\n                    rejected.call(void 0, error);\n                } catch (newError) {\n                    (Q.onerror || Promise_rethrow)(newError);\n                }\n            };\n        } else if (typeof rejected === \"function\") {\n            _rejected = function Promise_done_rejected(error) {\n                if (done) {\n                    return;\n                }\n                done = true;\n                makeStackTraceLong(error, self);\n                rejected.call(void 0, error);\n            };\n        } else {\n            _rejected = Q.onerror || Promise_rethrow;\n        }\n\n        if (typeof process === \"object\" && process.domain) {\n            _rejected = process.domain.bind(_rejected);\n        }\n\n        Q_getHandler(self).dispatch(_fulfilled, \"then\", [_rejected]);\n    });\n};\n\nfunction Promise_rethrow(error) {\n    throw error;\n}\n\n/**\n * TODO\n */\nPromise.prototype.thenResolve = function Promise_thenResolve(value) {\n    // Wrapping ahead of time to forestall multiple wrappers.\n    value = Q(value);\n    // Using all is necessary to aggregate the estimated time to completion.\n    return Q_all([this, value]).then(function Promise_thenResolve_resolved() {\n        return value;\n    }, null, 0);\n    // 0: does not contribute significantly to the estimated time to\n    // completion.\n};\n\n/**\n * TODO\n */\nPromise.prototype.thenReject = function Promise_thenReject(error) {\n    return this.then(function Promise_thenReject_resolved() {\n        throw error;\n    }, null, 0);\n    // 0: does not contribute significantly to the estimated time to\n    // completion.\n};\n\n/**\n * TODO\n */\nPromise.prototype.all = function Promise_all() {\n    return this.then(Q_all);\n};\n\n/**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */\nPromise.prototype.allSettled = function Promise_allSettled() {\n    return this.then(Q_allSettled);\n};\n\n/**\n * TODO\n */\nPromise.prototype.catch = function Promise_catch(rejected) {\n    return this.then(void 0, rejected);\n};\n\n/**\n * TODO\n */\nPromise.prototype.finally = function Promise_finally(callback, ms) {\n    if (!callback) {\n        return this;\n    }\n    callback = Q(callback);\n    return this.then(function (value) {\n        return callback.call().then(function Promise_finally_fulfilled() {\n            return value;\n        });\n    }, function (reason) {\n        // TODO attempt to recycle the rejection with \"this\".\n        return callback.call().then(function Promise_finally_rejected() {\n            throw reason;\n        });\n    }, ms);\n};\n\n/**\n * TODO\n */\nPromise.prototype.observeEstimate = function Promise_observeEstimate(emit) {\n    this.rawDispatch(null, \"estimate\", [emit]);\n    return this;\n};\n\n/**\n * TODO\n */\nPromise.prototype.getEstimate = function Promise_getEstimate() {\n    return Q_getHandler(this).estimate;\n};\n\n/**\n * TODO\n */\nPromise.prototype.dispatch = function Promise_dispatch(op, args) {\n    var deferred = defer();\n    this.rawDispatch(deferred.resolve, op, args);\n    return deferred.promise;\n};\n\n/**\n */\nPromise.prototype.rawDispatch = function Promise_rawDispatch(resolve, op, args) {\n    var self = this;\n    asap(function Promise_dispatch_task() {\n        Q_getHandler(self).dispatch(resolve, op, args);\n    });\n};\n\n/**\n * TODO\n */\nPromise.prototype.get = function Promise_get(name) {\n    return this.dispatch(\"get\", [name]);\n};\n\n/**\n * TODO\n */\nPromise.prototype.invoke = function Promise_invoke(name /*...args*/) {\n    var args = new Array(arguments.length - 1);\n    for (var index = 1; index < arguments.length; index++) {\n        args[index - 1] = arguments[index];\n    }\n    return this.dispatch(\"invoke\", [name, args]);\n};\n\n/**\n * TODO\n */\nPromise.prototype.apply = function Promise_apply(thisp, args) {\n    return this.dispatch(\"call\", [args, thisp]);\n};\n\n/**\n * TODO\n */\nPromise.prototype.call = function Promise_call(thisp /*, ...args*/) {\n    var args = new Array(Math.max(0, arguments.length - 1));\n    for (var index = 1; index < arguments.length; index++) {\n        args[index - 1] = arguments[index];\n    }\n    return this.dispatch(\"call\", [args, thisp]);\n};\n\n/**\n * TODO\n */\nPromise.prototype.bind = function Promise_bind(thisp /*, ...args*/) {\n    var self = this;\n    var args = new Array(Math.max(0, arguments.length - 1));\n    for (var index = 1; index < arguments.length; index++) {\n        args[index - 1] = arguments[index];\n    }\n    return function Promise_bind_bound(/*...args*/) {\n        var boundArgs = args.slice();\n        for (var index = 0; index < arguments.length; index++) {\n            boundArgs[boundArgs.length] = arguments[index];\n        }\n        return self.dispatch(\"call\", [boundArgs, thisp]);\n    };\n};\n\n/**\n * TODO\n */\nPromise.prototype.keys = function Promise_keys() {\n    return this.dispatch(\"keys\", []);\n};\n\n/**\n * TODO\n */\nPromise.prototype.iterate = function Promise_iterate() {\n    return this.dispatch(\"iterate\", []);\n};\n\n/**\n * TODO\n */\nPromise.prototype.spread = function Promise_spread(fulfilled, rejected, ms) {\n    return this.all().then(function Promise_spread_fulfilled(array) {\n        return fulfilled.apply(void 0, array);\n    }, rejected, ms);\n};\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Number} milliseconds timeout\n * @param {String} custom error message (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nPromise.prototype.timeout = function Promsie_timeout(ms, message) {\n    var deferred = defer();\n    var timeoutId = setTimeout(function Promise_timeout_task() {\n        deferred.reject(new Error(message || \"Timed out after \" + ms + \" ms\"));\n    }, ms);\n\n    this.then(function Promise_timeout_fulfilled(value) {\n        clearTimeout(timeoutId);\n        deferred.resolve(value);\n    }, function Promise_timeout_rejected(error) {\n        clearTimeout(timeoutId);\n        deferred.reject(error);\n    });\n\n    return deferred.promise;\n};\n\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\nPromise.prototype.delay = function Promise_delay(ms) {\n    return this.then(function Promise_delay_fulfilled(value) {\n        var deferred = defer();\n        deferred.setEstimate(Date.now() + ms);\n        setTimeout(function Promise_delay_task() {\n            deferred.resolve(value);\n        }, ms);\n        return deferred.promise;\n    }, null, ms);\n};\n\n/**\n * TODO\n */\nPromise.prototype.pull = function Promise_pull() {\n    return this.dispatch(\"pull\", []);\n};\n\n/**\n * TODO\n */\nPromise.prototype.pass = function Promise_pass() {\n    if (!this.toBePassed()) {\n        return new Promise(new Passed(this));\n    } else {\n        return this;\n    }\n};\n\n\n// Thus begins the portion dedicated to the deferred\n\nvar promises = new WeakMap();\n\nfunction Deferred(promise) {\n    this.promise = promise;\n    // A deferred has an intrinsic promise, denoted by its hidden handler\n    // property.  The promise property of the deferred may be assigned to a\n    // different promise (as it is in a Queue), but the intrinsic promise does\n    // not change.\n    promises.set(this, promise);\n    var self = this;\n    var resolve = this.resolve;\n    this.resolve = function (value) {\n        resolve.call(self, value);\n    };\n    var reject = this.reject;\n    this.reject = function (error) {\n        reject.call(self, error);\n    };\n}\n\n/**\n * TODO\n */\nDeferred.prototype.resolve = function Deferred_resolve(value) {\n    var handler = Q_getHandler(promises.get(this));\n    if (!handler.messages) {\n        return;\n    }\n    handler.become(Q(value));\n};\n\n/**\n * TODO\n */\nDeferred.prototype.reject = function Deferred_reject(reason) {\n    var handler = Q_getHandler(promises.get(this));\n    if (!handler.messages) {\n        return;\n    }\n    handler.become(Q_reject(reason));\n};\n\n/**\n * TODO\n */\nDeferred.prototype.setEstimate = function Deferred_setEstimate(estimate) {\n    estimate = +estimate;\n    if (estimate !== estimate) {\n        estimate = Infinity;\n    }\n    if (estimate < 1e12 && estimate !== -Infinity) {\n        throw new Error(\"Estimate values should be a number of miliseconds in the future\");\n    }\n    var handler = Q_getHandler(promises.get(this));\n    // TODO There is a bit of capability leakage going on here. The Deferred\n    // should only be able to set the estimate for its original\n    // Pending, not for any handler that promise subsequently became.\n    if (handler.setEstimate) {\n        handler.setEstimate(estimate);\n    }\n};\n\n// Thus ends the public interface\n\n// Thus begins the portion dedicated to handlers\n\nfunction Fulfilled(value) {\n    this.value = value;\n    this.estimate = Date.now();\n}\n\nFulfilled.prototype.state = \"fulfilled\";\n\nFulfilled.prototype.inspect = function Fulfilled_inspect() {\n    return {state: \"fulfilled\", value: this.value};\n};\n\nFulfilled.prototype.dispatch = function Fulfilled_dispatch(\n    resolve, op, operands\n) {\n    var result;\n    if (\n        op === \"then\" ||\n        op === \"get\" ||\n        op === \"call\" ||\n        op === \"invoke\" ||\n        op === \"keys\" ||\n        op === \"iterate\" ||\n        op === \"pull\"\n    ) {\n        try {\n            result = this[op].apply(this, operands);\n        } catch (exception) {\n            result = Q_reject(exception);\n        }\n    } else if (op === \"estimate\") {\n        operands[0].call(void 0, this.estimate);\n    } else {\n        var error = new Error(\n            \"Fulfilled promises do not support the \" + op + \" operator\"\n        );\n        result = Q_reject(error);\n    }\n    if (resolve) {\n        resolve(result);\n    }\n};\n\nFulfilled.prototype.then = function Fulfilled_then() {\n    return this.value;\n};\n\nFulfilled.prototype.get = function Fulfilled_get(name) {\n    return this.value[name];\n};\n\nFulfilled.prototype.call = function Fulfilled_call(args, thisp) {\n    return this.callInvoke(this.value, args, thisp);\n};\n\nFulfilled.prototype.invoke = function Fulfilled_invoke(name, args) {\n    return this.callInvoke(this.value[name], args, this.value);\n};\n\nFulfilled.prototype.callInvoke = function Fulfilled_callInvoke(callback, args, thisp) {\n    var waitToBePassed;\n    for (var index = 0; index < args.length; index++) {\n        if (Q_isPromise(args[index]) && args[index].toBePassed()) {\n            waitToBePassed = waitToBePassed || [];\n            waitToBePassed.push(args[index]);\n        }\n    }\n    if (waitToBePassed) {\n        var self = this;\n        return Q_all(waitToBePassed).then(function () {\n            return self.callInvoke(callback, args.map(function (arg) {\n                if (Q_isPromise(arg) && arg.toBePassed()) {\n                    return arg.inspect().value;\n                } else {\n                    return arg;\n                }\n            }), thisp);\n        });\n    } else {\n        return callback.apply(thisp, args);\n    }\n};\n\nFulfilled.prototype.keys = function Fulfilled_keys() {\n    return Object.keys(this.value);\n};\n\nFulfilled.prototype.iterate = function Fulfilled_iterate() {\n    return iterate(this.value);\n};\n\nFulfilled.prototype.pull = function Fulfilled_pull() {\n    var result;\n    if (Object(this.value) === this.value) {\n        result = Array.isArray(this.value) ? [] : {};\n        for (var name in this.value) {\n            result[name] = this.value[name];\n        }\n    } else {\n        result = this.value;\n    }\n    return Q.push(result);\n};\n\n\nfunction Rejected(reason) {\n    this.reason = reason;\n    this.estimate = Infinity;\n}\n\nRejected.prototype.state = \"rejected\";\n\nRejected.prototype.inspect = function Rejected_inspect() {\n    return {state: \"rejected\", reason: this.reason};\n};\n\nRejected.prototype.dispatch = function Rejected_dispatch(\n    resolve, op, operands\n) {\n    var result;\n    if (op === \"then\") {\n        result = this.then(resolve, operands[0]);\n    } else {\n        result = this;\n    }\n    if (resolve) {\n        resolve(result);\n    }\n};\n\nRejected.prototype.then = function Rejected_then(\n    resolve, rejected\n) {\n    return rejected ? rejected(this.reason) : this;\n};\n\n\nfunction Pending() {\n    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n    // element of the messages array is itself an array of complete arguments to\n    // forward to the resolved promise.  We coerce the resolution value to a\n    // promise using the `resolve` function because it handles both fully\n    // non-thenable values and other thenables gracefully.\n    this.messages = [];\n    this.observers = [];\n    this.estimate = Infinity;\n}\n\nPending.prototype.state = \"pending\";\n\nPending.prototype.inspect = function Pending_inspect() {\n    return {state: \"pending\"};\n};\n\nPending.prototype.dispatch = function Pending_dispatch(resolve, op, operands) {\n    this.messages.push([resolve, op, operands]);\n    if (op === \"estimate\") {\n        this.observers.push(operands[0]);\n        var self = this;\n        asap(function Pending_dispatch_task() {\n            operands[0].call(void 0, self.estimate);\n        });\n    }\n};\n\nPending.prototype.become = function Pending_become(promise) {\n    this.became = theViciousCycle;\n    var handler = Q_getHandler(promise);\n    this.became = handler;\n\n    handlers.set(promise, handler);\n    this.promise = void 0;\n\n    this.messages.forEach(function Pending_become_eachMessage(message) {\n        // makeQ does not have this asap call, so it must be queueing events\n        // downstream. TODO look at makeQ to ascertain\n        asap(function Pending_become_eachMessage_task() {\n            var handler = Q_getHandler(promise);\n            handler.dispatch.apply(handler, message);\n        });\n    });\n\n    this.messages = void 0;\n    this.observers = void 0;\n};\n\nPending.prototype.setEstimate = function Pending_setEstimate(estimate) {\n    if (this.observers) {\n        var self = this;\n        self.estimate = estimate;\n        this.observers.forEach(function Pending_eachObserver(observer) {\n            asap(function Pending_setEstimate_eachObserver_task() {\n                observer.call(void 0, estimate);\n            });\n        });\n    }\n};\n\nfunction Thenable(thenable) {\n    this.thenable = thenable;\n    this.became = null;\n    this.estimate = Infinity;\n}\n\nThenable.prototype.state = \"thenable\";\n\nThenable.prototype.inspect = function Thenable_inspect() {\n    return {state: \"pending\"};\n};\n\nThenable.prototype.cast = function Thenable_cast() {\n    if (!this.became) {\n        var deferred = defer();\n        var thenable = this.thenable;\n        asap(function Thenable_cast_task() {\n            try {\n                thenable.then(deferred.resolve, deferred.reject);\n            } catch (exception) {\n                deferred.reject(exception);\n            }\n        });\n        this.became = Q_getHandler(deferred.promise);\n    }\n    return this.became;\n};\n\nThenable.prototype.dispatch = function Thenable_dispatch(resolve, op, args) {\n    this.cast().dispatch(resolve, op, args);\n};\n\n\nfunction Passed(promise) {\n    this.promise = promise;\n}\n\nPassed.prototype.state = \"passed\";\n\nPassed.prototype.inspect = function Passed_inspect() {\n    return this.promise.inspect();\n};\n\nPassed.prototype.dispatch = function Passed_dispatch(resolve, op, args) {\n    return this.promise.rawDispatch(resolve, op, args);\n};\n\n\n// Thus begins the Q Node.js bridge\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.ninvoke = function Q_ninvoke(object, name /*...args*/) {\n    var args = new Array(Math.max(0, arguments.length - 1));\n    for (var index = 2; index < arguments.length; index++) {\n        args[index - 2] = arguments[index];\n    }\n    var deferred = Q.defer();\n    args[index - 2] = deferred.makeNodeResolver();\n    Q(object).dispatch(\"invoke\", [name, args]).catch(deferred.reject);\n    return deferred.promise;\n};\n\nPromise.prototype.ninvoke = function Promise_ninvoke(name /*...args*/) {\n    var args = new Array(arguments.length);\n    for (var index = 1; index < arguments.length; index++) {\n        args[index - 1] = arguments[index];\n    }\n    var deferred = Q.defer();\n    args[index - 1] = deferred.makeNodeResolver();\n    this.dispatch(\"invoke\", [name, args]).catch(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Wraps a Node.js continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.denodeify(FS.readFile)(__filename, \"utf-8\")\n * .then(console.log)\n * .done()\n */\nQ.denodeify = function Q_denodeify(callback, pattern) {\n    return function denodeified() {\n        var args = new Array(arguments.length + 1);\n        var index = 0;\n        for (; index < arguments.length; index++) {\n            args[index] = arguments[index];\n        }\n        var deferred = Q.defer();\n        args[index] = deferred.makeNodeResolver(pattern);\n        Q(callback).apply(this, args).catch(deferred.reject);\n        return deferred.promise;\n    };\n};\n\n/**\n * Creates a Node.js-style callback that will resolve or reject the deferred\n * promise.\n * @param unpack `true` means that the Node.js-style-callback accepts a\n * fixed or variable number of arguments and that the deferred should be resolved\n * with an array of these value arguments, or rejected with the error argument.\n * An array of names means that the Node.js-style-callback accepts a fixed\n * number of arguments, and that the resolution should be an object with\n * properties corresponding to the given names and respective value arguments.\n * @returns a nodeback\n */\nDeferred.prototype.makeNodeResolver = function (unpack) {\n    var resolve = this.resolve;\n    if (unpack === true) {\n        return function variadicNodebackToResolver(error) {\n            if (error) {\n                resolve(Q_reject(error));\n            } else {\n                var value = new Array(Math.max(0, arguments.length - 1));\n                for (var index = 1; index < arguments.length; index++) {\n                    value[index - 1] = arguments[index];\n                }\n                resolve(value);\n            }\n        };\n    } else if (unpack) {\n        return function namedArgumentNodebackToResolver(error) {\n            if (error) {\n                resolve(Q_reject(error));\n            } else {\n                var value = {};\n                for (var index = 0; index < unpack.length; index++) {\n                    value[unpack[index]] = arguments[index + 1];\n                }\n                resolve(value);\n            }\n        };\n    } else {\n        return function nodebackToResolver(error, value) {\n            if (error) {\n                resolve(Q_reject(error));\n            } else {\n                resolve(value);\n            }\n        };\n    }\n};\n\n/**\n * TODO\n */\nPromise.prototype.nodeify = function Promise_nodeify(nodeback) {\n    if (nodeback) {\n        this.done(function (value) {\n            nodeback(null, value);\n        }, nodeback);\n    } else {\n        return this;\n    }\n};\n\n\n// DEPRECATED\n\nQ.nextTick = deprecate(asap, \"nextTick\", \"asap package\");\n\nQ.resolve = deprecate(Q, \"resolve\", \"Q\");\n\nQ.fulfill = deprecate(Q, \"fulfill\", \"Q\");\n\nQ.isPromiseAlike = deprecate(isThenable, \"isPromiseAlike\", \"(not supported)\");\n\nQ.fail = deprecate(function (value, rejected) {\n    return Q(value).catch(rejected);\n}, \"Q.fail\", \"Q(value).catch\");\n\nQ.fin = deprecate(function (value, regardless) {\n    return Q(value).finally(regardless);\n}, \"Q.fin\", \"Q(value).finally\");\n\nQ.progress = deprecate(function (value) {\n    return value;\n}, \"Q.progress\", \"no longer supported\");\n\nQ.thenResolve = deprecate(function (promise, value) {\n    return Q(promise).thenResolve(value);\n}, \"thenResolve\", \"Q(value).thenResolve\");\n\nQ.thenReject = deprecate(function (promise, reason) {\n    return Q(promise).thenResolve(reason);\n}, \"thenResolve\", \"Q(value).thenResolve\");\n\nQ.isPending = deprecate(function (value) {\n    return Q(value).isPending();\n}, \"isPending\", \"Q(value).isPending\");\n\nQ.isFulfilled = deprecate(function (value) {\n    return Q(value).isFulfilled();\n}, \"isFulfilled\", \"Q(value).isFulfilled\");\n\nQ.isRejected = deprecate(function (value) {\n    return Q(value).isRejected();\n}, \"isRejected\", \"Q(value).isRejected\");\n\nQ.master = deprecate(function (value) {\n    return value;\n}, \"master\", \"no longer necessary\");\n\nQ.makePromise = function () {\n    throw new Error(\"makePromise is no longer supported\");\n};\n\nQ.dispatch = deprecate(function (value, op, operands) {\n    return Q(value).dispatch(op, operands);\n}, \"dispatch\", \"Q(value).dispatch\");\n\nQ.get = deprecate(function (object, name) {\n    return Q(object).get(name);\n}, \"get\", \"Q(value).get\");\n\nQ.keys = deprecate(function (object) {\n    return Q(object).keys();\n}, \"keys\", \"Q(value).keys\");\n\nQ.post = deprecate(function (object, name, args) {\n    return Q(object).post(name, args);\n}, \"post\", \"Q(value).invoke (spread arguments)\");\n\nQ.mapply = deprecate(function (object, name, args) {\n    return Q(object).post(name, args);\n}, \"post\", \"Q(value).invoke (spread arguments)\");\n\nQ.send = deprecate(function (object, name) {\n    return Q(object).post(name, Array.prototype.slice.call(arguments, 2));\n}, \"send\", \"Q(value).invoke\");\n\nQ.set = function () {\n    throw new Error(\"Q.set no longer supported\");\n};\n\nQ.delete = function () {\n    throw new Error(\"Q.delete no longer supported\");\n};\n\nQ.nearer = deprecate(function (value) {\n    if (Q_isPromise(value) && value.isFulfilled()) {\n        return value.inspect().value;\n    } else {\n        return value;\n    }\n}, \"nearer\", \"inspect().value (+nuances)\");\n\nQ.fapply = deprecate(function (callback, args) {\n    return Q(callback).dispatch(\"call\", [args]);\n}, \"fapply\", \"Q(callback).apply(thisp, args)\");\n\nQ.fcall = deprecate(function (callback /*, ...args*/) {\n    return Q(callback).dispatch(\"call\", [Array.prototype.slice.call(arguments, 1)]);\n}, \"fcall\", \"Q(callback).call(thisp, ...args)\");\n\nQ.fbind = deprecate(function (object /*...args*/) {\n    var promise = Q(object);\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function fbound() {\n        return promise.dispatch(\"call\", [\n            args.concat(Array.prototype.slice.call(arguments)),\n            this\n        ]);\n    };\n}, \"fbind\", \"bind with thisp\");\n\nQ.promise = deprecate(Promise, \"promise\", \"Promise\");\n\nPromise.prototype.fapply = deprecate(function (args) {\n    return this.dispatch(\"call\", [args]);\n}, \"fapply\", \"apply with thisp\");\n\nPromise.prototype.fcall = deprecate(function (/*...args*/) {\n    return this.dispatch(\"call\", [Array.prototype.slice.call(arguments)]);\n}, \"fcall\", \"try or call with thisp\");\n\nPromise.prototype.fail = deprecate(function (rejected) {\n    return this.catch(rejected);\n}, \"fail\", \"catch\");\n\nPromise.prototype.fin = deprecate(function (regardless) {\n    return this.finally(regardless);\n}, \"fin\", \"finally\");\n\nPromise.prototype.set = function () {\n    throw new Error(\"Promise set no longer supported\");\n};\n\nPromise.prototype.delete = function () {\n    throw new Error(\"Promise delete no longer supported\");\n};\n\nDeferred.prototype.notify = deprecate(function () {\n}, \"notify\", \"no longer supported\");\n\nPromise.prototype.progress = deprecate(function () {\n    return this;\n}, \"progress\", \"no longer supported\");\n\n// alternative proposed by Redsandro, dropped in favor of post to streamline\n// the interface\nPromise.prototype.mapply = deprecate(function (name, args) {\n    return this.dispatch(\"invoke\", [name, args]);\n}, \"mapply\", \"invoke\");\n\nPromise.prototype.fbind = deprecate(function () {\n    return Q.fbind.apply(Q, [void 0].concat(Array.prototype.slice.call(arguments)));\n}, \"fbind\", \"bind(thisp, ...args)\");\n\n// alternative proposed by Mark Miller, dropped in favor of invoke\nPromise.prototype.send = deprecate(function () {\n    return this.dispatch(\"invoke\", [name, Array.prototype.slice.call(arguments, 1)]);\n}, \"send\", \"invoke\");\n\n// alternative proposed by Redsandro, dropped in favor of invoke\nPromise.prototype.mcall = deprecate(function () {\n    return this.dispatch(\"invoke\", [name, Array.prototype.slice.call(arguments, 1)]);\n}, \"mcall\", \"invoke\");\n\nPromise.prototype.passByCopy = deprecate(function (value) {\n    return value;\n}, \"passByCopy\", \"Q.passByCopy\");\n\n// Deprecated Node.js bridge promise methods\n\nQ.nfapply = deprecate(function (callback, args) {\n    var deferred = Q.defer();\n    var nodeArgs = Array.prototype.slice.call(args);\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(callback).apply(this, nodeArgs).catch(deferred.reject);\n    return deferred.promise;\n}, \"nfapply\");\n\nPromise.prototype.nfapply = deprecate(function (args) {\n    return Q.nfapply(this, args);\n}, \"nfapply\");\n\nQ.nfcall = deprecate(function (callback /*...args*/) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return Q.nfapply(callback, args);\n}, \"nfcall\");\n\nPromise.prototype.nfcall = deprecate(function () {\n    var args = new Array(arguments.length);\n    for (var index = 0; index < arguments.length; index++) {\n        args[index] = arguments[index];\n    }\n    return Q.nfapply(this, args);\n}, \"nfcall\");\n\nQ.nfbind = deprecate(function (callback /*...args*/) {\n    var baseArgs = Array.prototype.slice.call(arguments, 1);\n    return function () {\n        var nodeArgs = baseArgs.concat(Array.prototype.slice.call(arguments));\n        var deferred = Q.defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        Q(callback).apply(this, nodeArgs).catch(deferred.reject);\n        return deferred.promise;\n    };\n}, \"nfbind\", \"denodeify (with caveats)\");\n\nPromise.prototype.nfbind = deprecate(function () {\n    var args = new Array(arguments.length);\n    for (var index = 0; index < arguments.length; index++) {\n        args[index] = arguments[index];\n    }\n    return Q.nfbind(this, args);\n}, \"nfbind\", \"denodeify (with caveats)\");\n\nQ.nbind = deprecate(function (callback, thisp /*...args*/) {\n    var baseArgs = Array.prototype.slice.call(arguments, 2);\n    return function () {\n        var nodeArgs = baseArgs.concat(Array.prototype.slice.call(arguments));\n        var deferred = Q.defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        function bound() {\n            return callback.apply(thisp, arguments);\n        }\n        Q(bound).apply(this, nodeArgs).catch(deferred.reject);\n        return deferred.promise;\n    };\n}, \"nbind\", \"denodeify (with caveats)\");\n\nQ.npost = deprecate(function (object, name, nodeArgs) {\n    var deferred = Q.defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(object).dispatch(\"invoke\", [name, nodeArgs]).catch(deferred.reject);\n    return deferred.promise;\n}, \"npost\", \"ninvoke (with spread arguments)\");\n\nPromise.prototype.npost = deprecate(function (name, args) {\n    return Q.npost(this, name, args);\n}, \"npost\", \"Q.ninvoke (with caveats)\");\n\nQ.nmapply = deprecate(Q.nmapply, \"nmapply\", \"q/node nmapply\");\nPromise.prototype.nmapply = deprecate(Promise.prototype.npost, \"nmapply\", \"Q.nmapply\");\n\nQ.nsend = deprecate(Q.ninvoke, \"nsend\", \"q/node ninvoke\");\nQ.nmcall = deprecate(Q.ninvoke, \"nmcall\", \"q/node ninvoke\");\nPromise.prototype.nsend = deprecate(Promise.prototype.ninvoke, \"nsend\", \"q/node ninvoke\");\nPromise.prototype.nmcall = deprecate(Promise.prototype.ninvoke, \"nmcall\", \"q/node ninvoke\");\n\n// All code before this point will be filtered from stack traces.\nvar qEndingLine = captureLine();\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}